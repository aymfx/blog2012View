import{_ as e,c as o,o as a,N as l}from"./chunks/framework.1f285265.js";const D=JSON.parse('{"title":"模块的分类","description":"模块的分类","frontmatter":{"title":"模块的分类","date":"2022-10-01T00:00:00.000Z","description":"模块的分类","tags":["node"]},"headers":[],"relativePath":"posts/前端/node/模块定义.md"}'),s={name:"posts/前端/node/模块定义.md"},n=l(`<ul><li><a href="https://nodejs.cn/api/" target="_blank" rel="noreferrer">API 文档 | Node.js 中文网</a></li><li><a href="https://chyingp.github.io/nodejs-learning-guide/%E6%A8%A1%E5%9D%97/zlib.html" target="_blank" rel="noreferrer">概览 | Nodejs 学习笔记</a></li><li><a href="https://theanarkh.github.io/understand-nodejs/" target="_blank" rel="noreferrer">Node.js 源码剖析</a></li><li><a href="https://github.com/parro-it/awesome-micro-npm-packages" target="_blank" rel="noreferrer">GitHub - parro-it/awesome-micro-npm-packages: A curated list of small, focused npm packages.</a></li></ul><blockquote><p>NodeJS 是采用 commonJS 规范的，可以通过 module.exports、require 来导出和引入模块</p></blockquote><h2 id="文件模块" tabindex="-1">文件模块 <a class="header-anchor" href="#文件模块" aria-label="Permalink to &quot;文件模块&quot;">​</a></h2><blockquote><p>NodJS 支持模块化变成，每个文件都可以当做一个模块，通过三个预设变量完成模块的导入导出</p></blockquote><p>*<strong>*模块仅在第一次加载中，执行一次，后面就被缓存起来，以便重复利用**</strong></p><ul><li>require 当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。</li><li>exports 将当前模块进行导出，可以是公有方法和属性</li><li>module 当前模块的一些相关信息</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">exports</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//true 说明exports是它的引用类型</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">module.</span><span style="color:#A6ACCD;">path)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//模块路径</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">module.filename</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//  文件路径 全路径</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// {}</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">module.id</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//用文件路径当id</span></span>
<span class="line"></span></code></pre></div><h2 id="软件包版本-npm" tabindex="-1">软件包版本 npm <a class="header-anchor" href="#软件包版本-npm" aria-label="Permalink to &quot;软件包版本 npm&quot;">​</a></h2><p>鉴于使用了 semver（语义版本控制），所有的版本都有 3 个数字，第一个是主版本，第二个是次版本，第三个是补丁版本</p><ul><li>如果写入的是 <code>〜0.13.0</code>，则只更新补丁版本：即 <code>0.13.1</code> 可以，但 <code>0.14.0</code> 不可以。</li><li>如果写入的是 <code>^0.13.0</code>，则要更新补丁版本和次版本：即 <code>0.13.1</code>、<code>0.14.0</code>、依此类推。</li><li>如果写入的是 <code>0.13.0</code>，则始终使用确切的版本。</li></ul><p>当发布新的版本时，不仅仅是随心所欲地增加数字，还要遵循以下规则</p><ul><li>当进行不兼容的 API 更改时，则升级主版本。</li><li>当以向后兼容的方式添加功能时，则升级次版本。</li><li>当进行向后兼容的缺陷修复时，则升级补丁版本。</li></ul><p>规则符号的含义</p><ul><li><code>^</code>: 只会执行不更改最左边非零数字的更新。 如果写入的是 <code>^0.13.0</code>，则当运行 <code>npm update</code> 时，可以更新到 <code>0.13.1</code>、<code>0.13.2</code> 等，但不能更新到 <code>0.14.0</code> 或更高版本。 如果写入的是 <code>^1.13.0</code>，则当运行 <code>npm update</code> 时，可以更新到 <code>1.13.1</code>、<code>1.14.0</code> 等，但不能更新到 <code>2.0.0</code> 或更高版本。</li><li><code>~</code>: 如果写入的是 <code>〜0.13.0</code>，则当运行 <code>npm update</code> 时，会更新到补丁版本：即 <code>0.13.1</code> 可以，但 <code>0.14.0</code> 不可以。</li><li><code>&gt;</code>: 接受高于指定版本的任何版本。</li><li><code>&gt;=</code>: 接受等于或高于指定版本的任何版本。</li><li><code>&lt;=</code>: 接受等于或低于指定版本的任何版本。</li><li><code>&lt;</code>: 接受低于指定版本的任何版本。</li><li><code>=</code>: 接受确切的版本。</li><li><code>-</code>: 接受一定范围的版本。例如：<code>2.1.0 - 2.6.2</code>。</li><li><code>||</code>: 组合集合。例如 <code>&lt; 2.1 || &gt; 2.6</code>。</li></ul><h3 id="系统模块" tabindex="-1">系统模块 <a class="header-anchor" href="#系统模块" aria-label="Permalink to &quot;系统模块&quot;">​</a></h3><ul><li><strong>C/C++ （built-in 内建模块），通过其 C 语言编写的模块，一般用于 native 模块调用</strong></li><li>native 模块，在开发中使用的 NodeJs 的 http、buffer、fs 等，底层也是调用的内建模块 (C/C++)。</li></ul><h3 id="第三方模块" tabindex="-1">第三方模块 <a class="header-anchor" href="#第三方模块" aria-label="Permalink to &quot;第三方模块&quot;">​</a></h3><ul><li>类似于 express、dayjs、koa 等都属于第三方编写的模块</li></ul><h3 id="node-modules-模块" tabindex="-1">node_modules 模块 <a class="header-anchor" href="#node-modules-模块" aria-label="Permalink to &quot;node_modules 模块&quot;">​</a></h3><h3 id="缓存模块" tabindex="-1">缓存模块 <a class="header-anchor" href="#缓存模块" aria-label="Permalink to &quot;缓存模块&quot;">​</a></h3><p>模块在首次加载的时候会被缓存，意味着如果模块名能解析为相同的文件名，那么在此调用时，都会返回同一模块。</p><h3 id="目录结构" tabindex="-1">目录结构 <a class="header-anchor" href="#目录结构" aria-label="Permalink to &quot;目录结构&quot;">​</a></h3><ul><li>项目内部编写的模块，常通过相对路径引入进来的</li></ul><h2 id="模块扩展名" tabindex="-1">模块扩展名 <a class="header-anchor" href="#模块扩展名" aria-label="Permalink to &quot;模块扩展名&quot;">​</a></h2><ul><li>.js javascript 模块</li><li>.json json 模块</li><li>.node C/C++模块</li></ul><h2 id="模块的加载机制" tabindex="-1">模块的加载机制 <a class="header-anchor" href="#模块的加载机制" aria-label="Permalink to &quot;模块的加载机制&quot;">​</a></h2><p>NodeJS 加载模块一般会经历三个步骤，==路径分析==、==文件定位==、==编译执行==</p><p>// TODO 还没写完</p>`,28),t=[n];function c(p,r,i,d,u,h){return a(),o("div",null,t)}const y=e(s,[["render",c]]);export{D as __pageData,y as default};
