<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <title>前端 react | Aymfx&#39;s Blog</title>
  
  <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1408911_ujc2i49ntb.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">
  <link rel="stylesheet" href="/css/style.css">
</head>
  <body>
    <div class='container'>
      <header id="header">
  <section class='header-main'>
    <div class='outer'>
        <a href="/" class="logo">Aymfx's Blog</a> 
      <nav class="navbar">
        
        <a href="/" class="menu-item-link">首页</a>
        
        <a href="/archives" class="menu-item-link">归档</a>
        
        <a href="/tags" class="menu-item-link">标签</a>
        
        <a href="/about" class="menu-item-link">关于我</a>
        
        <a href="/photos" class="menu-item-link">相册</a>
        
        <a href="https://github.com/aymfx" class="menu-item-link">交友</a>
        
      </nav>
    </div>
  </section>
</header>
    <main class="main">
      <div class='post-detail'>
    <div id="toc" class='left'>
    <h4>
        文章目录
    </h4>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#区分Real-DOM和Virtual-DOM"><span class="toc-text">区分Real DOM和Virtual DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是React"><span class="toc-text">什么是React</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React有什么特点"><span class="toc-text">React有什么特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-中-keys-的作用是什么？"><span class="toc-text">React 中 keys 的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用-setState-之后发生了什么？"><span class="toc-text">调用 setState 之后发生了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react-生命周期函数"><span class="toc-text">react 生命周期函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shouldComponentUpdate-是做什么的，（react-性能优化是哪个周期函数？）"><span class="toc-text">shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么虚拟-dom-会提高性能-必考"><span class="toc-text">为什么虚拟 dom 会提高性能?(必考)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react-diff-原理（常考，大厂必考）"><span class="toc-text">react diff 原理（常考，大厂必考）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-中-refs-的作用是什么？"><span class="toc-text">React 中 refs 的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#展示组件-Presentational-component-和容器组件-Container-component-之间有何不同"><span class="toc-text">展示组件(Presentational component)和容器组件(Container component)之间有何不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类组件-Class-component-和函数式组件-Functional-component-之间有何不同"><span class="toc-text">类组件(Class component)和函数式组件(Functional component)之间有何不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组件的-状态-state-和属性-props-之间有何不同"><span class="toc-text">(组件的)状态(state)和属性(props)之间有何不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#何为受控组件-controlled-component"><span class="toc-text">何为受控组件(controlled component)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#何为高阶组件-higher-order-component"><span class="toc-text">何为高阶组件(higher order component)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么建议传递给-setState-的参数是一个-callback-而不是一个对象"><span class="toc-text">为什么建议传递给 setState 的参数是一个 callback 而不是一个对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#除了在构造函数中绑定-this，还有其它方式吗"><span class="toc-text">除了在构造函数中绑定 this，还有其它方式吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在构造函数中-调用-super-props-的目的是什么"><span class="toc-text">(在构造函数中)调用 super(props) 的目的是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应该在-React-组件的何处发起-Ajax-请求"><span class="toc-text">应该在 React 组件的何处发起 Ajax 请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#描述事件在-React-中的处理方式。"><span class="toc-text">描述事件在 React 中的处理方式。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createElement-和-cloneElement-有什么区别？"><span class="toc-text">createElement 和 cloneElement 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-中有三种构建组件的方式"><span class="toc-text">React 中有三种构建组件的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react-组件的划分业务组件技术组件？"><span class="toc-text">react 组件的划分业务组件技术组件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简述-flux-思想"><span class="toc-text">简述 flux 思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-项目用过什么脚手架（本题是开放性题目）"><span class="toc-text">React 项目用过什么脚手架（本题是开放性题目）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#了解-redux-么，说一下-redux"><span class="toc-text">了解 redux 么，说一下 redux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redux-有什么缺点"><span class="toc-text">redux 有什么缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react-ref获取真实dom"><span class="toc-text">react ref获取真实dom</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react和vue对比"><span class="toc-text">react和vue对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模板和JSX"><span class="toc-text">模板和ＪＳＸ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生命周期-列出常用的"><span class="toc-text">生命周期(列出常用的)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态管理机制"><span class="toc-text">状态管理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16x后生命周期的替换"><span class="toc-text">16x后生命周期的替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getDerivedStateFromProps"><span class="toc-text">getDerivedStateFromProps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getSnapshotBeforeUpdate"><span class="toc-text">getSnapshotBeforeUpdate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setState"><span class="toc-text">setState</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-中-setState-什么时候是同步的，什么时候是异步的？"><span class="toc-text">React 中 setState 什么时候是同步的，什么时候是异步的？</span></a></li></ol>
</div>
    <article class="post-detail animated slideInDown right">
        <div class="post-title">
          <h2 class="title">前端 react</h2>
        </div>
         <div class="post-meta"> 
          <i class='iconfont iconriqi'></i>
          <span class="post-time">2019-05-11</span>
        </div>
        <div class="article-container">
          <blockquote>
<p>前端 react</p>
</blockquote>
<a id="more"></a> 
<p>##基本姿势</p>
<h3 id="区分Real-DOM和Virtual-DOM"><a href="#区分Real-DOM和Virtual-DOM" class="headerlink" title="区分Real DOM和Virtual DOM"></a>区分Real DOM和Virtual DOM</h3><p>真实dom</p>
<ul>
<li>更新缓慢</li>
<li>可以直接更新html</li>
<li>如果元素更新会导致重绘</li>
<li>消耗的性能较多</li>
</ul>
<p>虚拟dom</p>
<ul>
<li>更新更快</li>
<li>无法直接跟新html</li>
<li>一般操作jsx</li>
<li>dom操作简单</li>
</ul>
<h3 id="什么是React"><a href="#什么是React" class="headerlink" title="什么是React"></a>什么是React</h3><p>一个渐进式的web框架，是一个mvvm模式</p>
<h3 id="React有什么特点"><a href="#React有什么特点" class="headerlink" title="React有什么特点"></a>React有什么特点</h3><ul>
<li>它使用虚拟DOM 而不是真正的DOM。</li>
<li>它可以进行服务器端渲染。</li>
<li>它遵循单向数据流或数据绑定。</li>
</ul>
<h3 id="React-中-keys-的作用是什么？"><a href="#React-中-keys-的作用是什么？" class="headerlink" title="React 中 keys 的作用是什么？"></a>React 中 keys 的作用是什么？</h3><ul>
<li>便于追踪结点</li>
<li>有助于性能的提升，相对于简单的渲染排序来说</li>
<li>diff算法会借助key来减少不必要的dom渲染消耗</li>
</ul>
<h3 id="调用-setState-之后发生了什么？"><a href="#调用-setState-之后发生了什么？" class="headerlink" title="调用 setState 之后发生了什么？"></a>调用 setState 之后发生了什么？</h3><p>在代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p>
<h3 id="react-生命周期函数"><a href="#react-生命周期函数" class="headerlink" title="react 生命周期函数"></a>react 生命周期函数</h3><p>初始化阶段</p>
<ul>
<li>getDefaultProps:获取实例的默认属性</li>
<li>getInitialState:获取每个实例的初始化状态</li>
<li>componentWillMount：组件即将被装载、渲染到页面上</li>
<li>render:组件在这里生成虚拟的 DOM 节点</li>
<li>componentDidMount:组件真正在被装载之后</li>
</ul>
<p>运行中状态：</p>
<ul>
<li>componentWillReceiveProps:组件将要接收到属性的时候调用</li>
<li>shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）</li>
<li>componentWillUpdate:组件即将更新不能修改属性和状态</li>
<li>render:组件重新描绘</li>
<li>componentDidUpdate:组件已经更新</li>
</ul>
<p>销毁阶段：</p>
<ul>
<li>componentWillUnmount:组件即将销毁</li>
</ul>
<h3 id="shouldComponentUpdate-是做什么的，（react-性能优化是哪个周期函数？）"><a href="#shouldComponentUpdate-是做什么的，（react-性能优化是哪个周期函数？）" class="headerlink" title="shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）"></a>shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）</h3><p>shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。</p>
<h3 id="为什么虚拟-dom-会提高性能-必考"><a href="#为什么虚拟-dom-会提高性能-必考" class="headerlink" title="为什么虚拟 dom 会提高性能?(必考)"></a>为什么虚拟 dom 会提高性能?(必考)</h3><p>虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。</p>
<p>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。</p>
<h3 id="react-diff-原理（常考，大厂必考）"><a href="#react-diff-原理（常考，大厂必考）" class="headerlink" title="react diff 原理（常考，大厂必考）"></a>react diff 原理（常考，大厂必考）</h3><ul>
<li>把树形结构按照层级分解，只比较同级元素。</li>
<li>给列表结构的每个单元添加唯一的 key 属性，方便比较。</li>
<li>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）</li>
<li>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.</li>
<li>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</li>
</ul>
<h3 id="React-中-refs-的作用是什么？"><a href="#React-中-refs-的作用是什么？" class="headerlink" title="React 中 refs 的作用是什么？"></a>React 中 refs 的作用是什么？</h3><p>Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CustomForm extends Component &#123;</span><br><span class="line">  handleSubmit = () =&gt; &#123;</span><br><span class="line">    console.log(&quot;Input Value: &quot;, this.input.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&apos;text&apos;</span><br><span class="line">          ref=&#123;(input) =&gt; this.input = input&#125; /&gt;</span><br><span class="line">        &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中的 input 域包含了一个 ref 属性，该属性声明的回调函数会接收 input 对应的 DOM 元素，我们将其绑定到 this 指针以便在其他的类函数中使用。另外值得一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function CustomForm (&#123;handleSubmit&#125;) &#123;</span><br><span class="line">  let inputElement</span><br><span class="line">  return (</span><br><span class="line">    &lt;form onSubmit=&#123;() =&gt; handleSubmit(inputElement.value)&#125;&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=&apos;text&apos;</span><br><span class="line">        ref=&#123;(input) =&gt; inputElement = input&#125; /&gt;</span><br><span class="line">      &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="展示组件-Presentational-component-和容器组件-Container-component-之间有何不同"><a href="#展示组件-Presentational-component-和容器组件-Container-component-之间有何不同" class="headerlink" title="展示组件(Presentational component)和容器组件(Container component)之间有何不同"></a>展示组件(Presentational component)和容器组件(Container component)之间有何不同</h3><ul>
<li>展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态</li>
<li>容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。</li>
</ul>
<h3 id="类组件-Class-component-和函数式组件-Functional-component-之间有何不同"><a href="#类组件-Class-component-和函数式组件-Functional-component-之间有何不同" class="headerlink" title="类组件(Class component)和函数式组件(Functional component)之间有何不同"></a>类组件(Class component)和函数式组件(Functional component)之间有何不同</h3><ul>
<li>类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态</li>
<li>当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 ‘无状态组件(stateless component)’，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件</li>
</ul>
<h3 id="组件的-状态-state-和属性-props-之间有何不同"><a href="#组件的-状态-state-和属性-props-之间有何不同" class="headerlink" title="(组件的)状态(state)和属性(props)之间有何不同"></a>(组件的)状态(state)和属性(props)之间有何不同</h3><ul>
<li>State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。</li>
<li>Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。</li>
</ul>
<h3 id="何为受控组件-controlled-component"><a href="#何为受控组件-controlled-component" class="headerlink" title="何为受控组件(controlled component)"></a>何为受控组件(controlled component)</h3><p>在 HTML 中，类似 <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code> 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 onChange 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为”受控元素”。</p>
<h3 id="何为高阶组件-higher-order-component"><a href="#何为高阶组件-higher-order-component" class="headerlink" title="何为高阶组件(higher order component)"></a>何为高阶组件(higher order component)</h3><p>高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。</p>
<h3 id="为什么建议传递给-setState-的参数是一个-callback-而不是一个对象"><a href="#为什么建议传递给-setState-的参数是一个-callback-而不是一个对象" class="headerlink" title="为什么建议传递给 setState 的参数是一个 callback 而不是一个对象"></a>为什么建议传递给 setState 的参数是一个 callback 而不是一个对象</h3><p>因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。</p>
<h3 id="除了在构造函数中绑定-this，还有其它方式吗"><a href="#除了在构造函数中绑定-this，还有其它方式吗" class="headerlink" title="除了在构造函数中绑定 this，还有其它方式吗"></a>除了在构造函数中绑定 this，还有其它方式吗</h3><p>你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。</p>
<h3 id="在构造函数中-调用-super-props-的目的是什么"><a href="#在构造函数中-调用-super-props-的目的是什么" class="headerlink" title="(在构造函数中)调用 super(props) 的目的是什么"></a>(在构造函数中)调用 super(props) 的目的是什么</h3><p>在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。</p>
<h3 id="应该在-React-组件的何处发起-Ajax-请求"><a href="#应该在-React-组件的何处发起-Ajax-请求" class="headerlink" title="应该在 React 组件的何处发起 Ajax 请求"></a>应该在 React 组件的何处发起 Ajax 请求</h3><p>在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 componentDidMount 中发起网络请求将保证这有一个组件可以更新了。</p>
<h3 id="描述事件在-React-中的处理方式。"><a href="#描述事件在-React-中的处理方式。" class="headerlink" title="描述事件在 React 中的处理方式。"></a>描述事件在 React 中的处理方式。</h3><p>为了解决跨浏览器兼容性问题，您的 React 中的事件处理程序将传递 SyntheticEvent 的实例，它是 React 的浏览器本机事件的跨浏览器包装器。</p>
<p>这些 SyntheticEvent 与您习惯的原生事件具有相同的接口，除了它们在所有浏览器中都兼容。有趣的是，React 实际上并没有将事件附加到子节点本身。React 将使用单个事件监听器监听顶层的所有事件。这对于性能是有好处的，这也意味着在更新 DOM 时，React 不需要担心跟踪事件监听器。</p>
<h3 id="createElement-和-cloneElement-有什么区别？"><a href="#createElement-和-cloneElement-有什么区别？" class="headerlink" title="createElement 和 cloneElement 有什么区别？"></a>createElement 和 cloneElement 有什么区别？</h3><p>React.createElement():JSX 语法就是用 React.createElement()来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如 div、span，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">    type,</span><br><span class="line">    [props],</span><br><span class="line">    [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>React.cloneElement()与 React.createElement()相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而就的子元素奖杯替换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.cloneElement(</span><br><span class="line">  element,</span><br><span class="line">  [props],</span><br><span class="line">  [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="React-中有三种构建组件的方式"><a href="#React-中有三种构建组件的方式" class="headerlink" title="React 中有三种构建组件的方式"></a>React 中有三种构建组件的方式</h3><p>React.createClass()、ES6 class 和无状态函数。</p>
<h3 id="react-组件的划分业务组件技术组件？"><a href="#react-组件的划分业务组件技术组件？" class="headerlink" title="react 组件的划分业务组件技术组件？"></a>react 组件的划分业务组件技术组件？</h3><ul>
<li>根据组件的职责通常把组件分为 UI 组件和容器组件。</li>
<li>UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</li>
<li>两者通过 React-Redux 提供 connect 方法联系起来。</li>
</ul>
<h3 id="简述-flux-思想"><a href="#简述-flux-思想" class="headerlink" title="简述 flux 思想"></a>简述 flux 思想</h3><p>Flux 的最大特点，就是数据的”单向流动”。</p>
<h3 id="React-项目用过什么脚手架（本题是开放性题目）"><a href="#React-项目用过什么脚手架（本题是开放性题目）" class="headerlink" title="React 项目用过什么脚手架（本题是开放性题目）"></a>React 项目用过什么脚手架（本题是开放性题目）</h3><p>creat-react-app Yeoman 等</p>
<h3 id="了解-redux-么，说一下-redux"><a href="#了解-redux-么，说一下-redux" class="headerlink" title="了解 redux 么，说一下 redux"></a>了解 redux 么，说一下 redux</h3><ul>
<li>redux 是一个应用数据流框架，主要是解决了组件间状态共享的问题，原理是集中式管理，主要有三个核心方法，action，store，reducer，工作流程是 view 调用 store 的 dispatch 接收 action 传入 store，reducer 进行 state 操作，view 通过 store 提供的 getState 获取最新的数据，flux 也是用来进行数据操作的，有四个组成部分 action，dispatch，view，store，工作流程是 view 发出一个 action，派发器接收 action，让 store 进行数据更新，更新完成以后 store 发出 change，view 接受 change 更新视图。Redux 和 Flux 很像。主要区别在于 Flux 有多个可以改变应用状态的 store，在 Flux 中 dispatcher 被用来传递数据到注册的回调事件，但是在 redux 中只能定义一个可更新状态的 store，redux 把 store 和 Dispatcher 合并,结构更加简单清晰</li>
<li>新增 state,对状态的管理更加明确，通过 redux，流程更加规范了，减少手动编码量，提高了编码效率，同时缺点时当数据更新时有时候组件不需要，但是也要重新绘制，有些影响效率。一般情况下，我们在构建多交互，多数据流的复杂项目应用时才会使用它们</li>
</ul>
<h3 id="redux-有什么缺点"><a href="#redux-有什么缺点" class="headerlink" title="redux 有什么缺点"></a>redux 有什么缺点</h3><ul>
<li>一个组件所需要的数据，必须由父组件传过来，而不能像 flux 中直接从 store 取。</li>
<li>当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新 render，可能会有效率影响，或者需要写复杂的 shouldComponentUpdate 进行判断。</li>
</ul>
<h3 id="react-ref获取真实dom"><a href="#react-ref获取真实dom" class="headerlink" title="react ref获取真实dom"></a>react ref获取真实dom</h3><ol>
<li>ref 方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ref=&#123;ref=&gt; this.div = ref&#125; /&gt;</span><br><span class="line">// 通过this.div获取</span><br></pre></td></tr></table></figure>

<ol>
<li>refs</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ref=&apos;div&apos; /&gt;</span><br><span class="line">// 通过this.refs.div获取</span><br></pre></td></tr></table></figure>

<ol>
<li>React.createRef()</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// constructor</span><br><span class="line">this.div = React.createRef()</span><br><span class="line">// render</span><br><span class="line">&lt;div ref=&#123;this.div&#125; /&gt;</span><br><span class="line">// 通过this.div获取</span><br></pre></td></tr></table></figure>

<h3 id="react和vue对比"><a href="#react和vue对比" class="headerlink" title="react和vue对比"></a>react和vue对比</h3><ul>
<li><h3 id="模板和JSX"><a href="#模板和JSX" class="headerlink" title="模板和ＪＳＸ"></a>模板和ＪＳＸ</h3></li>
<li><h3 id="生命周期-列出常用的"><a href="#生命周期-列出常用的" class="headerlink" title="生命周期(列出常用的)"></a>生命周期(列出常用的)</h3></li>
<li><h3 id="状态管理机制"><a href="#状态管理机制" class="headerlink" title="状态管理机制"></a><strong>状态管理机制</strong></h3></li>
<li><p><strong><em>组件传值</em></strong></p>
</li>
</ul>
<h3 id="16x后生命周期的替换"><a href="#16x后生命周期的替换" class="headerlink" title="16x后生命周期的替换"></a>16x后生命周期的替换</h3><p><img src="images/image-20190730192835409.png" alt="image-20190730192835409"></p>
<ul>
<li><h3 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a><code>getDerivedStateFromProps</code></h3></li>
<li><h3 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a><code>getSnapshotBeforeUpdate</code></h3></li>
</ul>
<h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p>1、第一次和第二次都是在 react 自身生命周期内，触发时 isBatchingUpdates 为 true，所以并不会直接执行更新 state，而是加入了 dirtyComponents，所以打印时获取的都是更新前的状态 0。</p>
<p>2、两次 setState 时，获取到 this.state.val 都是 0，所以执行时都是将 0 设置成 1，在 react 内部会被合并掉，只执行一次。设置完成后 state.val 值为 1。</p>
<p>3、setTimeout 中的代码，触发时 isBatchingUpdates 为 false，所以能够直接进行更新，所以连着输出 2，3。</p>
<p>isBatchingUpdates 默认值为 false，当 react 自身的事件处理函数或 react 生命周期触发时，isBatchingUpdates 会被赋值为 true，当更新完成时又会被复原为 false</p>
<h3 id="React-中-setState-什么时候是同步的，什么时候是异步的？"><a href="#React-中-setState-什么时候是同步的，什么时候是异步的？" class="headerlink" title="React 中 setState 什么时候是同步的，什么时候是异步的？"></a>React 中 setState 什么时候是同步的，什么时候是异步的？</h3><p>在React中，<strong>如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，除此之外的setState调用会同步执行this.state</strong>。所谓“除此之外”，指的是绕过React通过addEventListener直接添加的事件处理函数，还有通过setTimeout/setInterval产生的异步调用。</p>
<p><strong>原因：</strong>在React的setState函数实现中，会根据一个变量isBatchingUpdates判断是直接更新this.state还是放到队列中回头再说，而isBatchingUpdates默认是false，也就表示setState会同步更新this.state，但是，<strong>有一个函数batchedUpdates，这个函数会把isBatchingUpdates修改为true，而当React在调用事件处理函数之前就会调用这个batchedUpdates，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state</strong>。</p>
 
        </div> 
      </article> 
</div>



    </main>
    </div>
  </body>
</html>